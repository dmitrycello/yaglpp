#pragma once
#include "gladpp.h"
#include "_Object.h"
namespace gl {
/*GLAD basic shader type enumerator*/
enum class ShaderType : GLenum
{
	/*Fragment shader type. The shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value*/
	FragmentShader = GL_FRAGMENT_SHADER,

	/*Vertex shader type. The programmable shader stage in the rendering pipeline that handles the processing of individual vertices*/
	VertexShader = GL_VERTEX_SHADER,

#ifdef GL_VERSION_3_2
	/*(3.2) Geometry shader type. The shader program written in GLSL that governs the processing of primitives*/
	GeometryShader = GL_GEOMETRY_SHADER,
#endif // #ifdef GL_VERSION_3_2
};

/*OpenGL shader object abstract class derived from <_Object>*/
class _Shader : public _Object
{
protected:
	_Shader() : _Object() {}

	GLuint _shader_id(GLenum shaderType)
	{
		return _object_id(&_glCreateShader, shaderType);
	}

	void _attachShader(GLenum shaderType, Program& program);
	void _compileShader(GLenum shaderType);
	void _detachShader(GLenum shaderType, Program& program);
	GLint _getShader(GLenum shaderType, GLenum pname);
	GLchar* _getShaderSource(GLenum shaderType);
	void _getShaderSource(GLenum shaderType, GLsizei bufSize, GLsizei* length, GLchar* source);
	static void _glCreateShader(GLsizei shaderType, GLuint* id);
	static void _glDeleteShader(GLsizei unused, const GLuint* id);
	void _shaderSource(GLenum shaderType, int rcid);
	void _shaderSource(GLenum shaderType, const char* filepath);
	void _shaderSource(GLenum shaderType, GLsizei count, const GLchar** string, const GLint* length);

public:
	/*Explicitly deletes previously generated shader object*/
	void deleteShader()
	{
		_object_delete(&_glDeleteShader);
	}

	/*Determines via API if the name of a shader object previously created with <createShader> and not yet deleted with <deleteShader>
	@return True if valid shader object, false otherwise*/
	GLboolean isShader()
	{
		return glIsShader(_object_id());
	}
}; // class _Shader

#ifndef _DEBUG
inline void _Shader::_compileShader(GLenum shaderType)
{
	glCompileShader(_shader_id(shaderType));
}

inline void _Shader::_createShader(GLenum shaderType)
{
	m_uShader = glCreateShader(shaderType);
}

inline void _Shader::_deleteShader(GLenum shaderType)
{
	glDeleteShader(m_uShader); m_uShader = 0;
}

inline GLint _Shader::_getShader(GLenum shaderType, GLenum pname)
{
	GLint i; glGetShaderiv(_shader_id(shaderType), pname, &i); return i;
}

inline void _Shader::_getShaderSource(GLenum shaderType, GLsizei bufSize, GLsizei* length, GLchar* source)
{
	glGetShaderSource(_shader_id(shaderType), bufSize, length, source);
}

inline void _Shader::_shaderSource(GLenum shaderType, GLsizei count, const GLchar** string, const GLint* length)
{
	glShaderSource(_shader_id(shaderType), count, string, length);
}
#endif // #ifndef _DEBUG
} // namespace gl

#include "Program.h"
namespace gl {
#ifndef _DEBUG
inline void _Shader::_attachShader(GLenum shaderType, Program& program)
{
	glAttachShader(program._program_id(), _shader_id(shaderType));
}

inline void _Shader::_detachShader(GLenum shaderType, Program& program)
{
	glDetachShader(program._program_id(), _shader_id(shaderType));
}
#endif // #ifndef _DEBUG
} // namespace gl

#ifndef GLPP_BUILD_LIB
#include "VertexShader.h"
#include "FragmentShader.h"
#include "GeometryShader.h"
#endif // #ifdef GLPP_BUILD
